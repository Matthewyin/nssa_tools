<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MLG 消除逻辑修复测试</title>
  <style>
    body { font-family: monospace; padding: 20px; background: #f5f5f5; }
    .test-case { background: white; margin: 10px 0; padding: 15px; border-radius: 8px; border-left: 4px solid #007acc; }
    .result { margin: 10px 0; padding: 10px; border-radius: 4px; }
    .success { background: #d4edda; color: #155724; }
    .error { background: #f8d7da; color: #721c24; }
    .info { background: #d1ecf1; color: #0c5460; }
    .slot-display { display: flex; gap: 5px; margin: 10px 0; }
    .slot-item { width: 40px; height: 40px; border: 2px solid #ccc; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 20px; }
    button { padding: 8px 16px; margin: 5px; border: none; border-radius: 4px; cursor: pointer; }
    .btn-test { background: #007acc; color: white; }
    .btn-reset { background: #6c757d; color: white; }
  </style>
</head>
<body>
  <h1>MLG 消除逻辑修复测试</h1>
  <p>这个页面用于测试MLG游戏中槽位消除逻辑的修复效果。</p>

  <div class="test-case">
    <h3>测试场景：槽位中有4个相同图标</h3>
    <div id="test-slot" class="slot-display">
      <div class="slot-item">🐱</div>
      <div class="slot-item">🐱</div>
      <div class="slot-item">🐱</div>
      <div class="slot-item">🐱</div>
      <div class="slot-item" style="border-style: dashed; color: #ccc;">空</div>
      <div class="slot-item" style="border-style: dashed; color: #ccc;">空</div>
      <div class="slot-item" style="border-style: dashed; color: #ccc;">空</div>
      <div class="slot-item" style="border-style: dashed; color: #ccc;">空</div>
    </div>
    <button class="btn-test" onclick="testElimination()">测试消除逻辑</button>
    <button class="btn-reset" onclick="resetTest()">重置测试</button>
    <div id="test-result" class="result info">点击"测试消除逻辑"按钮开始测试</div>
  </div>

  <div class="test-case">
    <h3>修复说明</h3>
    <div class="result info">
      <strong>问题原因：</strong><br>
      1. 原来的消除逻辑只在添加新tile时检查<br>
      2. 撤销操作后没有重新检查消除逻辑<br>
      3. 可能导致槽位中出现超过3个相同类型的情况<br><br>
      
      <strong>修复方案：</strong><br>
      1. 创建独立的 <code>checkSlotElimination()</code> 函数<br>
      2. 在撤销操作后调用消除检查<br>
      3. 在游戏加载时也检查并修复槽位状态<br>
      4. 支持连续消除，直到没有可消除的组合<br><br>
      
      <strong>测试方法：</strong><br>
      1. 模拟槽位中有4个相同图标的情况<br>
      2. 调用消除逻辑函数<br>
      3. 验证是否正确消除了3个，剩余1个
    </div>
  </div>

  <script>
    // 模拟MLG游戏的消除逻辑
    function checkSlotElimination(slot, tiles) {
      let hasElimination = true;
      const eliminated = [];
      
      // 持续检查直到没有可消除的组合
      while (hasElimination) {
        hasElimination = false;
        
        // 统计每种类型的数量
        const typeCount = {};
        slot.forEach(id => {
          const tile = tiles.find(t => t.id === id);
          if (tile) {
            typeCount[tile.type] = (typeCount[tile.type] || 0) + 1;
          }
        });
        
        // 检查是否有类型数量 >= 3
        for (const [type, count] of Object.entries(typeCount)) {
          if (count >= 3) {
            hasElimination = true;
            
            // 找到该类型的前3个tile并移除
            const toRemove = [];
            for (const id of slot) {
              const tile = tiles.find(t => t.id === id);
              if (tile && tile.type === parseInt(type)) {
                toRemove.push(id);
                if (toRemove.length === 3) break;
              }
            }
            
            // 从槽位中移除
            slot = slot.filter(id => !toRemove.includes(id));
            eliminated.push(...toRemove);
            
            // 只处理一种类型，然后重新开始循环
            break;
          }
        }
      }
      
      return { slot, eliminated };
    }
    
    function testElimination() {
      // 模拟测试数据
      const tiles = [
        { id: 1, type: 1 }, // 🐱
        { id: 2, type: 1 }, // 🐱
        { id: 3, type: 1 }, // 🐱
        { id: 4, type: 1 }, // 🐱
      ];
      
      let slot = [1, 2, 3, 4]; // 4个相同的图标
      
      const resultEl = document.getElementById('test-result');
      resultEl.innerHTML = `
        <strong>测试开始：</strong><br>
        初始槽位：[${slot.join(', ')}] (4个相同图标)<br>
        <br>
        执行消除逻辑...<br>
      `;
      
      setTimeout(() => {
        const result = checkSlotElimination(slot, tiles);
        
        const success = result.slot.length === 1 && result.eliminated.length === 3;
        
        resultEl.className = `result ${success ? 'success' : 'error'}`;
        resultEl.innerHTML += `
          <strong>测试结果：</strong><br>
          消除后槽位：[${result.slot.join(', ')}]<br>
          被消除的：[${result.eliminated.join(', ')}]<br>
          <br>
          <strong>${success ? '✅ 测试通过' : '❌ 测试失败'}：</strong>
          ${success ? '正确消除了3个，剩余1个' : '消除逻辑有问题'}
        `;
        
        // 更新可视化显示
        updateSlotDisplay(result.slot);
      }, 500);
    }
    
    function updateSlotDisplay(slot) {
      const slotEl = document.getElementById('test-slot');
      const items = slotEl.children;
      
      for (let i = 0; i < items.length; i++) {
        if (i < slot.length) {
          items[i].textContent = '🐱';
          items[i].style.borderStyle = 'solid';
          items[i].style.color = 'black';
        } else {
          items[i].textContent = '空';
          items[i].style.borderStyle = 'dashed';
          items[i].style.color = '#ccc';
        }
      }
    }
    
    function resetTest() {
      const resultEl = document.getElementById('test-result');
      resultEl.className = 'result info';
      resultEl.textContent = '点击"测试消除逻辑"按钮开始测试';
      
      // 重置显示
      const slotEl = document.getElementById('test-slot');
      const items = slotEl.children;
      
      for (let i = 0; i < items.length; i++) {
        if (i < 4) {
          items[i].textContent = '🐱';
          items[i].style.borderStyle = 'solid';
          items[i].style.color = 'black';
        } else {
          items[i].textContent = '空';
          items[i].style.borderStyle = 'dashed';
          items[i].style.color = '#ccc';
        }
      }
    }
  </script>
</body>
</html>
