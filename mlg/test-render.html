<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MLG 立方体渲染测试</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="css/style.css" />
  <link rel="stylesheet" href="css/theme.css" />
</head>
<body class="min-h-screen">
  <main class="mx-auto max-w-5xl px-4 py-6" style="color: var(--text-color-primary)">
    <h1 class="text-2xl font-bold mb-4">MLG 立方体渲染效果测试</h1>
    <p class="mb-4 text-sm text-gray-600">
      测试修改后的立方体渲染效果：背景色与页面一致，手机端自动缩放
    </p>
    <p class="mb-4 text-xs text-gray-500">
      屏幕宽度: <span id="screen-width"></span>px | 缩放比例: <span id="scale-info"></span>
    </p>
    
    <div id="game-container" class="game-container mlg-card" style="background: var(--card-bg);">
      <canvas id="test-canvas" class="game-canvas" style="height: 400px;"></canvas>
    </div>
    
    <div class="mt-4 text-sm text-gray-600">
      <p>渲染特点：</p>
      <ul class="list-disc list-inside mt-2">
        <li>背景色与页面一致：#f5f5f7</li>
        <li>响应式缩放：手机端自动缩小立方体</li>
        <li>新颜色方案：顶层 #FFFDE7，下层 #B0BEC5，更下层 #90A4AE，最下层 #546E7A</li>
        <li>业务逻辑：每个位置的最上层立方体都显示为顶层亮色</li>
        <li>立体边框：主边框 + 高光边框 + 侧面阴影</li>
        <li>符号透明度：顶层最清晰，下层逐渐透明</li>
      </ul>
    </div>
  </main>

  <script src="js/game.js"></script>
  <script>
    // 简单的测试渲染
    const canvas = document.getElementById('test-canvas');
    const ctx = canvas.getContext('2d');
    
    // 设置画布尺寸
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
    
    // 测试立方体数据 - 模拟不同位置的顶层情况
    const testTiles = [
      { layer: 0, type: 0, x: 50, y: 50, col: 0, row: 0 },   // 位置(0,0)的底层
      { layer: 2, type: 1, x: 50, y: 50, col: 0, row: 0 },   // 位置(0,0)的顶层
      { layer: 1, type: 2, x: 150, y: 50, col: 1, row: 0 },  // 位置(1,0)的顶层
      { layer: 0, type: 3, x: 250, y: 50, col: 2, row: 0 },  // 位置(2,0)的底层
      { layer: 1, type: 4, x: 250, y: 50, col: 2, row: 0 },  // 位置(2,0)的中层
      { layer: 3, type: 5, x: 250, y: 50, col: 2, row: 0 },  // 位置(2,0)的顶层
    ];
    
    // 显示屏幕信息
    const screenWidth = window.innerWidth;
    let scale = 1;
    if (screenWidth <= 480) {
      scale = 0.6;
    } else if (screenWidth <= 640) {
      scale = 0.7;
    } else if (screenWidth <= 768) {
      scale = 0.85;
    }

    document.getElementById('screen-width').textContent = screenWidth;
    document.getElementById('scale-info').textContent = scale;

    // 清空画布并设置背景
    ctx.fillStyle = '#f5f5f7';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // 测试符号
    const symbols = ['🐱', '🐶', '🐭', '🐹'];
    
    // 计算每个位置的顶层信息
    const positionTopLayers = new Map();
    testTiles.forEach(tile => {
      const posKey = `${tile.col},${tile.row}`;
      const currentMax = positionTopLayers.get(posKey) || -1;
      if (tile.layer > currentMax) {
        positionTopLayers.set(posKey, tile.layer);
      }
    });

    // 绘制测试立方体 - 使用响应式大小和新逻辑
    testTiles.forEach((tile, index) => {
      const baseFrontW = 80;
      const frontW = Math.floor(baseFrontW * scale);
      const frontH = Math.floor(frontW * 2.2 / 2);
      const depth = Math.floor(frontW * 0.2);

      // 计算相对深度
      const posKey = `${tile.col},${tile.row}`;
      const topLayerAtPos = positionTopLayers.get(posKey);
      const isTopAtPosition = tile.layer === topLayerAtPos;
      const relativeDepth = topLayerAtPos - tile.layer;

      // 使用MLG的drawCuboid方法
      if (window.MLG && window.MLG.drawCuboid) {
        window.MLG.drawCuboid(ctx, tile.x, tile.y, frontW, frontH, depth, {
          actualLayer: tile.layer,
          isTopAtPosition: isTopAtPosition,
          relativeDepth: relativeDepth
        });

        // 绘制符号
        const fontSize = Math.floor(Math.min(frontW, frontH) * 0.6);
        ctx.font = `${fontSize}px system-ui`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // 使用新的符号透明度逻辑
        if (isTopAtPosition) {
          ctx.fillStyle = 'rgba(31, 41, 55, 1)';
        } else {
          const symbolOpacity = Math.max(0.3, 1 - (relativeDepth * 0.25));
          ctx.fillStyle = `rgba(31, 41, 55, ${symbolOpacity})`;
        }
        ctx.fillText(symbols[index], tile.x + frontW / 2, tile.y + frontH / 2);
      }
    });
    
    // 添加说明文字
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.font = '14px system-ui';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    ctx.fillText('层级 0-3 立方体渲染测试', 10, 10);

    // 监听窗口大小变化
    function handleResize() {
      // 重新渲染
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;

      // 更新屏幕信息并重新绘制
      const newScreenWidth = window.innerWidth;
      let newScale = 1;
      if (newScreenWidth <= 480) {
        newScale = 0.6;
      } else if (newScreenWidth <= 640) {
        newScale = 0.7;
      } else if (newScreenWidth <= 768) {
        newScale = 0.85;
      }

      document.getElementById('screen-width').textContent = newScreenWidth;
      document.getElementById('scale-info').textContent = newScale;

      // 重新绘制所有内容
      ctx.fillStyle = '#f5f5f7';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      testTiles.forEach((tile, index) => {
        const baseFrontW = 80;
        const frontW = Math.floor(baseFrontW * newScale);
        const frontH = Math.floor(frontW * 2.2 / 2);
        const depth = Math.floor(frontW * 0.2);

        // 计算相对深度
        const posKey = `${tile.col},${tile.row}`;
        const topLayerAtPos = positionTopLayers.get(posKey);
        const isTopAtPosition = tile.layer === topLayerAtPos;
        const relativeDepth = topLayerAtPos - tile.layer;

        if (window.MLG && window.MLG.drawCuboid) {
          window.MLG.drawCuboid(ctx, tile.x, tile.y, frontW, frontH, depth, {
            actualLayer: tile.layer,
            isTopAtPosition: isTopAtPosition,
            relativeDepth: relativeDepth
          });

          const fontSize = Math.floor(Math.min(frontW, frontH) * 0.6);
          ctx.font = `${fontSize}px system-ui`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';

          // 使用新的符号透明度逻辑
          if (isTopAtPosition) {
            ctx.fillStyle = 'rgba(31, 41, 55, 1)';
          } else {
            const symbolOpacity = Math.max(0.3, 1 - (relativeDepth * 0.25));
            ctx.fillStyle = `rgba(31, 41, 55, ${symbolOpacity})`;
          }
          ctx.fillText(symbols[index], tile.x + frontW / 2, tile.y + frontH / 2);
        }
      });

      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.font = '14px system-ui';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.fillText('层级 0-3 立方体渲染测试', 10, 10);
    }

    window.addEventListener('resize', handleResize);
  </script>
</body>
</html>
