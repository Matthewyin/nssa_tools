<!doctype html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MLG ç«‹æ–¹ä½“æ ·å¼æµ‹è¯•</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .game-container {
      background: #fff7ed;
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    }

    .game-canvas {
      background: #fff7ed;
      border-radius: 8px;
      width: 100%;
      height: 400px;
    }
  </style>
</head>

<body class="min-h-screen bg-slate-100 p-4">
  <div class="max-w-4xl mx-auto">
    <h1 class="text-2xl font-bold mb-4">MLG ç«‹æ–¹ä½“æ ·å¼æµ‹è¯•</h1>
    <div class="mb-4">
      <button id="refresh-btn" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded">
        ğŸ”„ é‡æ–°ç”Ÿæˆå¸ƒå±€
      </button>
    </div>
    <div class="game-container">
      <canvas id="test-canvas" class="game-canvas"></canvas>
    </div>
    <div class="mt-4 text-sm text-gray-600">
      <p>æµ‹è¯•æ–°çš„ç«‹æ–¹ä½“æ ·å¼ï¼š</p>
      <ul class="list-disc list-inside mt-2">
        <li>é•¿å®½é«˜æ¯”è°ƒæ•´ä¸º 2:2:0.3ï¼ˆæ­£æ–¹å½¢å‰é¢ï¼‰</li>
        <li>æ­£é¢åº•è‰²ç»Ÿä¸€ä¸º #FFFFCCï¼ˆæµ…é»„è‰²ï¼‰</li>
        <li>7Ã—10 ç½‘æ ¼å¸ƒå±€ï¼Œéšæœºæ”¾ç½®ç«‹æ–¹ä½“</li>
        <li>å±‚çº§é¢œè‰²ç³»ç»Ÿï¼šé¡¶å±‚æœ€äº®ï¼Œä¸‹å±‚é€æ¸å˜æš—</li>
        <li>å·¦ä¸‹å€¾æ–œæ–¹å‘ï¼ˆå·¦ä¾§é¢å’Œåº•é¢å¯è§ï¼‰</li>
      </ul>
    </div>
  </div>

  <script>
    // ç®€åŒ–çš„æµ‹è¯•ä»£ç 
    const canvas = document.getElementById('test-canvas');
    const ctx = canvas.getContext('2d');
    const refreshBtn = document.getElementById('refresh-btn');

    // è®¾ç½®ç”»å¸ƒå°ºå¯¸
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;

    // æµ‹è¯•é¢œè‰²è°ƒè‰²æ¿ - æŸ”å’Œè‰²è°ƒ
    const COLOR_PALETTE = [
      '#dc8a8a', '#e6a373', '#d4c078', '#7db88a', '#6bb6c7', '#8bb4f0',
      '#b19cd9', '#e091b8', '#d4a574', '#a8c77a', '#6ba8a0', '#9ca3f7'
    ];

    // æµ‹è¯•ç¬¦å·
    const SYMBOLS = ['ğŸ±', 'ğŸ¶', 'ğŸ­', 'ğŸ¹', 'ğŸ°', 'ğŸ¦Š', 'ğŸ»', 'ğŸ¼', 'ğŸ¨', 'ğŸ¯', 'ğŸ¦', 'ğŸ®'];

    // é¢œè‰²è°ƒæ•´å‡½æ•°
    function adjustHexColor(hex, amount) {
      try {
        const m = /^#?([0-9a-fA-F]{6})$/.exec(String(hex || ''));
        if (!m) return hex;
        const v = m[1];
        const r = parseInt(v.slice(0, 2), 16);
        const g = parseInt(v.slice(2, 4), 16);
        const b = parseInt(v.slice(4, 6), 16);
        const clamp255 = (n) => Math.max(0, Math.min(255, Math.round(n)));
        const adj = (c) => clamp255(c + amount * 255);
        const toHex = (n) => n.toString(16).padStart(2, '0');
        return `#${toHex(adj(r))}${toHex(adj(g))}${toHex(adj(b))}`;
      } catch { return hex; }
    }

    // ç»˜åˆ¶åœ†è§’çŸ©å½¢è·¯å¾„
    function createRoundedRectPath(ctx, x, y, width, height, radius) {
      const r = Math.max(2, Math.min(radius || 8, Math.min(width, height) / 4));
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + width - r, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + r);
      ctx.lineTo(x + width, y + height - r);
      ctx.quadraticCurveTo(x + width, y + height, x + width - r, y + height);
      ctx.lineTo(x + r, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
    }

    // ç»˜åˆ¶ç«‹æ–¹ä½“ - å·¦ä¸‹å€¾æ–œæ–¹å‘ï¼Œç»Ÿä¸€æµ…é»„è‰²æ­£é¢
    function drawCuboid(ctx, frontX, frontY, frontW, frontH, depth, options) {
      const o = options || {};
      const layerDepth = o.layerDepth || 0; // å±‚çº§æ·±åº¦ï¼Œ0ä¸ºé¡¶å±‚

      // ç»Ÿä¸€çš„æµ…é»„è‰²æ­£é¢ï¼Œæ ¹æ®å±‚çº§è°ƒæ•´äº®åº¦
      const baseFrontColor = '#FFFFCC';
      const frontColor = adjustHexColor(baseFrontColor, -0.15 * layerDepth);

      const bottomColor = adjustHexColor(frontColor, -0.25);
      const leftColor = adjustHexColor(frontColor, -0.4);

      const radius = Math.max(3, Math.floor(Math.min(frontW, frontH) * 0.08));
      const d = Math.max(1, Math.floor(depth));

      const fx = frontX, fy = frontY, fw = frontW, fh = frontH;
      const A = { x: fx, y: fy };        // å‰å·¦ä¸Š
      const B = { x: fx + fw, y: fy };   // å‰å³ä¸Š
      const C = { x: fx + fw, y: fy + fh }; // å‰å³ä¸‹
      const D = { x: fx, y: fy + fh };   // å‰å·¦ä¸‹
      // å·¦ä¸‹å€¾æ–œ
      const A2 = { x: A.x - d, y: A.y + d }; // åå·¦ä¸Š
      const B2 = { x: B.x - d, y: B.y + d }; // åå³ä¸Š
      const C2 = { x: C.x - d, y: C.y + d }; // åå³ä¸‹
      const D2 = { x: D.x - d, y: D.y + d }; // åå·¦ä¸‹

      ctx.save();

      const roundedQuadPath = (ctx, P0, P1, P2, P3, rad) => {
        const pts = [P0, P1, P2, P3];
        const lerp = (p, q, t) => ({ x: p.x + (q.x - p.x) * t, y: p.y + (q.y - p.y) * t });
        ctx.beginPath();
        for (let i = 0; i < 4; i++) {
          const prev = pts[(i + 3) % 4];
          const curr = pts[i];
          const next = pts[(i + 1) % 4];
          const d1 = Math.hypot(curr.x - prev.x, curr.y - prev.y) || 1;
          const d2 = Math.hypot(next.x - curr.x, next.y - curr.y) || 1;
          const rr = Math.min(rad, d1 / 3, d2 / 3);
          const pA = lerp(curr, prev, rr / d1);
          const pB = lerp(curr, next, rr / d2);
          if (i === 0) ctx.moveTo(pA.x, pA.y); else ctx.lineTo(pA.x, pA.y);
          ctx.quadraticCurveTo(curr.x, curr.y, pB.x, pB.y);
        }
        ctx.closePath();
      };

      const sideRadius = Math.max(2, Math.floor(radius * 0.6));

      // åº•é¢ D-C-C2-D2
      roundedQuadPath(ctx, D, C, C2, D2, sideRadius);
      const bottomGradient = ctx.createLinearGradient(D.x, D.y, D2.x, D2.y);
      bottomGradient.addColorStop(0, bottomColor);
      bottomGradient.addColorStop(1, adjustHexColor(bottomColor, -0.15));
      ctx.fillStyle = bottomGradient;
      ctx.fill();

      // å·¦ä¾§é¢ A-D-D2-A2
      roundedQuadPath(ctx, A, D, D2, A2, sideRadius);
      const leftGradient = ctx.createLinearGradient(A.x, A.y, A2.x, A2.y);
      leftGradient.addColorStop(0, leftColor);
      leftGradient.addColorStop(1, adjustHexColor(leftColor, -0.15));
      ctx.fillStyle = leftGradient;
      ctx.fill();

      // å‰æ–¹é¢ A-B-C-D
      createRoundedRectPath(ctx, fx, fy, fw, fh, radius);
      const frontGradient = ctx.createLinearGradient(fx, fy, fx + fw, fy + fh);
      frontGradient.addColorStop(0, adjustHexColor(frontColor, 0.1));
      frontGradient.addColorStop(0.5, frontColor);
      frontGradient.addColorStop(1, adjustHexColor(frontColor, -0.1));
      ctx.fillStyle = frontGradient;
      ctx.fill();

      ctx.strokeStyle = adjustHexColor(frontColor, -0.2);
      ctx.lineWidth = 0.5;
      ctx.stroke();

      ctx.restore();
    }

    // æ¸…ç©ºç”»å¸ƒ
    ctx.fillStyle = '#fff7ed';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // 7Ã—10 ç½‘æ ¼å¸ƒå±€æµ‹è¯•
    const gridCols = 7;
    const gridRows = 10;
    const gridWidth = canvas.width - 40; // ç•™å‡ºè¾¹è·
    const gridHeight = canvas.height - 40;
    const cellWidth = gridWidth / gridCols;
    const cellHeight = gridHeight / gridRows;
    const cellSize = Math.min(cellWidth, cellHeight);

    // ç«‹æ–¹ä½“å°ºå¯¸ - 2:2:0.3 æ¯”ä¾‹
    const cubeWidth = Math.floor(cellSize * 0.8); // ç•™å‡ºä¸€äº›é—´è·
    const cubeHeight = cubeWidth; // 2:2 æ¯”ä¾‹ï¼Œæ­£æ–¹å½¢å‰é¢
    const depth = Math.floor(cubeWidth * 0.3); // æ·±åº¦æ¯”ä¾‹ 0.3

    const startX = 20 + depth; // ä¸ºå·¦ä¾§é¢ç•™å‡ºç©ºé—´
    const startY = 20;

    // éšæœºç”Ÿæˆç«‹æ–¹ä½“ä½ç½®å’Œå±‚çº§
    const cubes = [];
    for (let row = 0; row < gridRows; row++) {
      for (let col = 0; col < gridCols; col++) {
        // éšæœºå†³å®šæ˜¯å¦åœ¨æ­¤ä½ç½®æ”¾ç½®ç«‹æ–¹ä½“
        if (Math.random() < 0.6) { // 60% æ¦‚ç‡æ”¾ç½®ç«‹æ–¹ä½“
          const layerCount = Math.floor(Math.random() * 3) + 1; // 1-3å±‚
          for (let layer = 0; layer < layerCount; layer++) {
            cubes.push({
              col,
              row,
              layer,
              symbol: SYMBOLS[Math.floor(Math.random() * SYMBOLS.length)],
              type: Math.floor(Math.random() * COLOR_PALETTE.length)
            });
          }
        }
      }
    }

    // æŒ‰å±‚çº§æ’åºï¼Œå…ˆç»˜åˆ¶åº•å±‚
    cubes.sort((a, b) => a.layer - b.layer);

    // ç»˜åˆ¶æ‰€æœ‰ç«‹æ–¹ä½“
    for (const cube of cubes) {
      const x = startX + cube.col * cellWidth;
      const y = startY + cube.row * cellHeight;

      // è®¡ç®—è¯¥ä½ç½®çš„æœ€å¤§å±‚çº§ï¼ˆç”¨äºç¡®å®šå½“å‰ç«‹æ–¹ä½“çš„ç›¸å¯¹æ·±åº¦ï¼‰
      const maxLayerAtPos = Math.max(...cubes.filter(c => c.col === cube.col && c.row === cube.row).map(c => c.layer));
      const layerDepth = maxLayerAtPos - cube.layer; // 0ä¸ºé¡¶å±‚ï¼Œæ•°å€¼è¶Šå¤§è¶Šæ·±

      // è®¾ç½®é˜´å½± - é€‚åº”å·¦ä¸‹å€¾æ–œ
      ctx.shadowColor = 'rgba(0,0,0,0.25)';
      ctx.shadowBlur = 4;
      ctx.shadowOffsetX = -4; // å‘å·¦åç§»
      ctx.shadowOffsetY = 6; // å‘ä¸‹åç§»

      // ç»˜åˆ¶ç«‹æ–¹ä½“
      drawCuboid(ctx, x, y, cubeWidth, cubeHeight, depth, { layerDepth });

      // é‡ç½®é˜´å½±
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;

      // ç»˜åˆ¶ç¬¦å·
      const fontSize = Math.floor(cubeHeight * 0.6);
      ctx.font = `${fontSize}px system-ui`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      // ç¬¦å·é˜´å½±
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.fillText(cube.symbol, x + cubeWidth / 2 + 1, y + cubeHeight / 2 + 2);

      // ä¸»ç¬¦å· - æ ¹æ®å±‚çº§è°ƒæ•´é¢œè‰²
      const symbolOpacity = 1 - (layerDepth * 0.2); // æ·±å±‚ç¬¦å·ç¨å¾®é€æ˜
      ctx.fillStyle = `rgba(31, 41, 55, ${symbolOpacity})`;
      ctx.fillText(cube.symbol, x + cubeWidth / 2, y + cubeHeight / 2);
    }

    // ç»˜åˆ¶ç½‘æ ¼çº¿ï¼ˆè°ƒè¯•ç”¨ï¼‰
    ctx.strokeStyle = 'rgba(0,0,0,0.1)';
    ctx.lineWidth = 1;
    for (let i = 0; i <= gridCols; i++) {
      const x = startX + i * cellWidth;
      ctx.beginPath();
      ctx.moveTo(x, startY);
      ctx.lineTo(x, startY + gridHeight);
      ctx.stroke();
    }
    for (let i = 0; i <= gridRows; i++) {
      const y = startY + i * cellHeight;
      ctx.beginPath();
      ctx.moveTo(startX, y);
      ctx.lineTo(startX + gridWidth, y);
      ctx.stroke();
    }

    // å°†ç»˜åˆ¶é€»è¾‘å°è£…ä¸ºå‡½æ•°
    function drawScene() {
      // è®¾ç½®ç”»å¸ƒå°ºå¯¸
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;

      // æ¸…ç©ºç”»å¸ƒ
      ctx.fillStyle = '#fff7ed';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // 7Ã—10 ç½‘æ ¼å¸ƒå±€æµ‹è¯•
      const gridCols = 7;
      const gridRows = 10;
      const gridWidth = canvas.width - 40; // ç•™å‡ºè¾¹è·
      const gridHeight = canvas.height - 40;
      const cellWidth = gridWidth / gridCols;
      const cellHeight = gridHeight / gridRows;
      const cellSize = Math.min(cellWidth, cellHeight);

      // ç«‹æ–¹ä½“å°ºå¯¸ - 2:2:0.3 æ¯”ä¾‹
      const cubeWidth = Math.floor(cellSize * 0.8); // ç•™å‡ºä¸€äº›é—´è·
      const cubeHeight = cubeWidth; // 2:2 æ¯”ä¾‹ï¼Œæ­£æ–¹å½¢å‰é¢
      const depth = Math.floor(cubeWidth * 0.3); // æ·±åº¦æ¯”ä¾‹ 0.3

      const startX = 20 + depth; // ä¸ºå·¦ä¾§é¢ç•™å‡ºç©ºé—´
      const startY = 20;

      // éšæœºç”Ÿæˆç«‹æ–¹ä½“ä½ç½®å’Œå±‚çº§
      const cubes = [];
      for (let row = 0; row < gridRows; row++) {
        for (let col = 0; col < gridCols; col++) {
          // éšæœºå†³å®šæ˜¯å¦åœ¨æ­¤ä½ç½®æ”¾ç½®ç«‹æ–¹ä½“
          if (Math.random() < 0.6) { // 60% æ¦‚ç‡æ”¾ç½®ç«‹æ–¹ä½“
            const layerCount = Math.floor(Math.random() * 3) + 1; // 1-3å±‚
            for (let layer = 0; layer < layerCount; layer++) {
              cubes.push({
                col,
                row,
                layer,
                symbol: SYMBOLS[Math.floor(Math.random() * SYMBOLS.length)],
                type: Math.floor(Math.random() * COLOR_PALETTE.length)
              });
            }
          }
        }
      }

      // æŒ‰å±‚çº§æ’åºï¼Œå…ˆç»˜åˆ¶åº•å±‚
      cubes.sort((a, b) => a.layer - b.layer);

      // ç»˜åˆ¶æ‰€æœ‰ç«‹æ–¹ä½“
      for (const cube of cubes) {
        const x = startX + cube.col * cellWidth;
        const y = startY + cube.row * cellHeight;

        // è®¡ç®—è¯¥ä½ç½®çš„æœ€å¤§å±‚çº§ï¼ˆç”¨äºç¡®å®šå½“å‰ç«‹æ–¹ä½“çš„ç›¸å¯¹æ·±åº¦ï¼‰
        const maxLayerAtPos = Math.max(...cubes.filter(c => c.col === cube.col && c.row === cube.row).map(c => c.layer));
        const layerDepth = maxLayerAtPos - cube.layer; // 0ä¸ºé¡¶å±‚ï¼Œæ•°å€¼è¶Šå¤§è¶Šæ·±

        // è®¾ç½®é˜´å½± - é€‚åº”å·¦ä¸‹å€¾æ–œ
        ctx.shadowColor = 'rgba(0,0,0,0.25)';
        ctx.shadowBlur = 4;
        ctx.shadowOffsetX = -4; // å‘å·¦åç§»
        ctx.shadowOffsetY = 6; // å‘ä¸‹åç§»

        // ç»˜åˆ¶ç«‹æ–¹ä½“
        drawCuboid(ctx, x, y, cubeWidth, cubeHeight, depth, { layerDepth });

        // é‡ç½®é˜´å½±
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;

        // ç»˜åˆ¶ç¬¦å·
        const fontSize = Math.floor(cubeHeight * 0.6);
        ctx.font = `${fontSize}px system-ui`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // ç¬¦å·é˜´å½±
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillText(cube.symbol, x + cubeWidth / 2 + 1, y + cubeHeight / 2 + 2);

        // ä¸»ç¬¦å· - æ ¹æ®å±‚çº§è°ƒæ•´é¢œè‰²
        const symbolOpacity = 1 - (layerDepth * 0.2); // æ·±å±‚ç¬¦å·ç¨å¾®é€æ˜
        ctx.fillStyle = `rgba(31, 41, 55, ${symbolOpacity})`;
        ctx.fillText(cube.symbol, x + cubeWidth / 2, y + cubeHeight / 2);
      }

      // ç»˜åˆ¶ç½‘æ ¼çº¿ï¼ˆè°ƒè¯•ç”¨ï¼‰
      ctx.strokeStyle = 'rgba(0,0,0,0.1)';
      ctx.lineWidth = 1;
      for (let i = 0; i <= gridCols; i++) {
        const x = startX + i * cellWidth;
        ctx.beginPath();
        ctx.moveTo(x, startY);
        ctx.lineTo(x, startY + gridHeight);
        ctx.stroke();
      }
      for (let i = 0; i <= gridRows; i++) {
        const y = startY + i * cellHeight;
        ctx.beginPath();
        ctx.moveTo(startX, y);
        ctx.lineTo(startX + gridWidth, y);
        ctx.stroke();
      }
    }

    // åˆå§‹ç»˜åˆ¶
    drawScene();

    // åˆ·æ–°æŒ‰é’®äº‹ä»¶
    refreshBtn.addEventListener('click', drawScene);
  </script>
</body>

</html>