<!doctype html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MLG ç«‹æ–¹ä½“æ ·å¼æµ‹è¯•</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .game-container {
      background: #F9FBE7;
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    }

    .game-canvas {
      background: #F9FBE7;
      border-radius: 8px;
      width: 100%;
      height: 700px;
      /* è¿›ä¸€æ­¥å¢åŠ é«˜åº¦é¿å…é®æŒ¡ */
    }
  </style>
</head>

<body class="min-h-screen bg-slate-100 p-4">
  <div class="max-w-4xl mx-auto">
    <h1 class="text-2xl font-bold mb-4">MLG ç«‹æ–¹ä½“æ ·å¼æµ‹è¯•</h1>
    <div class="mb-4">
      <button id="refresh-btn" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded">
        ğŸ”„ é‡æ–°ç”Ÿæˆå¸ƒå±€
      </button>
    </div>
    <div class="game-container">
      <canvas id="test-canvas" class="game-canvas"></canvas>
    </div>
    <div class="mt-4 text-sm text-gray-600">
      <p>æµ‹è¯•æ–°çš„ç«‹æ–¹ä½“æ ·å¼ï¼š</p>
      <ul class="list-disc list-inside mt-2">
        <li>æ–¹æ¡ˆCå¸ƒå±€ï¼šæ¯å±‚7Ã—9ç½‘æ ¼ï¼Œ45åº¦è§’å±‚çº§åç§»</li>
        <li>æµ…é»„è‰²èƒŒæ™¯ï¼š#FFFFCCï¼Œæ¸©æš–æŸ”å’Œ</li>
        <li>å±‚çº§é¢œè‰²ï¼šé¡¶å±‚æœ€äº® #E8F5E8ï¼Œé€çº§å˜æš—åˆ°åº•å±‚ #A0B8A0</li>
        <li>è¾¹æ¡†é¢œè‰²ï¼šå¯¹åº”çš„æ·±ç»¿è‰²è¾¹æ¡†ï¼Œå±‚çº§è¶Šä½è¶Šæš—</li>
        <li>ç«‹ä½“è¾¹æ¡†ï¼šä¸»è¾¹æ¡† + é«˜å…‰è¾¹æ¡† + åº•éƒ¨é˜´å½±çº¿</li>
        <li>45åº¦åç§»ï¼šæ¯å±‚å‘å³ä¸‹åç§»åŠä¸ªæ ¼å­è·ç¦»</li>
        <li>å›¾æ ‡å¤§å°æ‰©å±•è‡³ç«‹æ–¹ä½“è¾¹ç¼˜ï¼ˆ90% å‰é¢å¤§å°ï¼‰</li>
        <li>æ¯å±‚ç‹¬ç«‹éšæœºåˆ†å¸ƒï¼šåº•å±‚60%æ¦‚ç‡ï¼Œä¸Šå±‚é€’å‡10%</li>
        <li>æœ‰åºå±‚æ¬¡ï¼šè§„å¾‹çš„åç§»åˆ›é€ æ¸…æ™°çš„å±‚æ¬¡æ„Ÿ</li>
      </ul>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('test-canvas');
    const ctx = canvas.getContext('2d');
    const refreshBtn = document.getElementById('refresh-btn');

    // æµ‹è¯•ç¬¦å·
    const SYMBOLS = ['ğŸ±', 'ğŸ¶', 'ğŸ­', 'ğŸ¹', 'ğŸ°', 'ğŸ¦Š', 'ğŸ»', 'ğŸ¼', 'ğŸ¨', 'ğŸ¯', 'ğŸ¦', 'ğŸ®'];

    // é¢œè‰²è°ƒæ•´å‡½æ•°
    function adjustHexColor(hex, amount) {
      try {
        const m = /^#?([0-9a-fA-F]{6})$/.exec(String(hex || ''));
        if (!m) return hex;
        const v = m[1];
        const r = parseInt(v.slice(0, 2), 16);
        const g = parseInt(v.slice(2, 4), 16);
        const b = parseInt(v.slice(4, 6), 16);
        const clamp255 = (n) => Math.max(0, Math.min(255, Math.round(n)));
        const adj = (c) => clamp255(c + amount * 255);
        const toHex = (n) => n.toString(16).padStart(2, '0');
        return `#${toHex(adj(r))}${toHex(adj(g))}${toHex(adj(b))}`;
      } catch { return hex; }
    }

    // ç»˜åˆ¶åœ†è§’çŸ©å½¢è·¯å¾„
    function createRoundedRectPath(ctx, x, y, width, height, radius) {
      const r = Math.max(2, Math.min(radius || 8, Math.min(width, height) / 4));
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + width - r, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + r);
      ctx.lineTo(x + width, y + height - r);
      ctx.quadraticCurveTo(x + width, y + height, x + width - r, y + height);
      ctx.lineTo(x + r, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
    }

    // ç»˜åˆ¶ç«‹æ–¹ä½“ - å·¦ä¸‹å€¾æ–œæ–¹å‘ï¼Œå±‚çº§é¢œè‰²åŒºåˆ†
    function drawCuboid(ctx, frontX, frontY, frontW, frontH, depth, options) {
      const o = options || {};
      const actualLayer = o.actualLayer || 0;
      const maxLayers = 4;
      let frontColor, borderColor;

      // æ¯ä¸ªå±‚çº§éƒ½æœ‰ä¸åŒçš„é¢œè‰²ï¼Œä»é¡¶å±‚æœ€äº®åˆ°åº•å±‚æœ€æš—
      const layerColors = [
        { front: '#A0B8A0', border: '#1A3010' }, // å±‚çº§0ï¼ˆåº•å±‚ï¼‰ï¼šæœ€æš—
        { front: '#B0C8B0', border: '#1F3515' }, // å±‚çº§1ï¼šè¾ƒæš—
        { front: '#C0D8C0', border: '#243A1A' }, // å±‚çº§2ï¼šç¨äº®
        { front: '#E8F5E8', border: '#2D5016' }  // å±‚çº§3ï¼ˆé¡¶å±‚ï¼‰ï¼šæœ€äº®
      ];

      const colorIndex = Math.min(actualLayer, layerColors.length - 1);
      frontColor = layerColors[colorIndex].front;
      borderColor = layerColors[colorIndex].border;

      const radius = 6;
      const thickness = Math.floor(frontW * 0.1); // åšåº¦ä¸ºå®½åº¦çš„0.1å€

      ctx.save();

      // ç»˜åˆ¶å³ä¾§åšåº¦é¢ï¼ˆä½“ç°åšåº¦ï¼‰
      if (thickness > 0) {
        const sideColor = adjustHexColor(frontColor, -0.2); // ä¾§é¢ç¨æš—
        ctx.fillStyle = sideColor;
        ctx.beginPath();
        ctx.moveTo(frontX + frontW, frontY + radius);
        ctx.lineTo(frontX + frontW + thickness, frontY + radius - thickness);
        ctx.lineTo(frontX + frontW + thickness, frontY + frontH - radius - thickness);
        ctx.lineTo(frontX + frontW, frontY + frontH - radius);
        ctx.closePath();
        ctx.fill();

        // ä¾§é¢è¾¹æ¡†
        ctx.strokeStyle = adjustHexColor(borderColor, -0.1);
        ctx.lineWidth = 1;
        ctx.stroke();
      }

      // ç»˜åˆ¶é¡¶éƒ¨åšåº¦é¢ï¼ˆä½“ç°åšåº¦ï¼‰
      if (thickness > 0) {
        const topColor = adjustHexColor(frontColor, -0.15); // é¡¶é¢ç¨æš—
        ctx.fillStyle = topColor;
        ctx.beginPath();
        ctx.moveTo(frontX + radius, frontY);
        ctx.lineTo(frontX + radius + thickness, frontY - thickness);
        ctx.lineTo(frontX + frontW - radius + thickness, frontY - thickness);
        ctx.lineTo(frontX + frontW - radius, frontY);
        ctx.closePath();
        ctx.fill();

        // é¡¶é¢è¾¹æ¡†
        ctx.strokeStyle = adjustHexColor(borderColor, -0.1);
        ctx.lineWidth = 1;
        ctx.stroke();
      }

      // ç»˜åˆ¶ä¸»ä½“çŸ©å½¢ï¼ˆæ­£é¢ï¼‰
      createRoundedRectPath(ctx, frontX, frontY, frontW, frontH, radius);
      ctx.fillStyle = frontColor;
      ctx.fill();

      // ç»˜åˆ¶ä¸»è¾¹æ¡†
      ctx.strokeStyle = borderColor;
      ctx.lineWidth = 2.5;
      ctx.stroke();

      // ç»˜åˆ¶å†…éƒ¨é«˜å…‰è¾¹æ¡†ï¼ˆæ¨¡æ‹Ÿç«‹ä½“æ•ˆæœï¼‰
      createRoundedRectPath(ctx, frontX + 2, frontY + 2, frontW - 4, frontH - 4, radius - 2);
      ctx.strokeStyle = adjustHexColor(frontColor, 0.15);
      ctx.lineWidth = 1;
      ctx.stroke();

      ctx.restore();
    }

    // ç»˜åˆ¶åœºæ™¯
    function drawScene() {
      // è®¾ç½®ç”»å¸ƒå°ºå¯¸
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;

      // æ¸…ç©ºç”»å¸ƒ - æ·¡ç»¿é»„è‰²èƒŒæ™¯
      ctx.fillStyle = '#F9FBE7';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // 7Ã—9 ç½‘æ ¼å¸ƒå±€æµ‹è¯•ï¼ˆæ–¹æ¡ˆCï¼‰
      const gridCols = 7;
      const gridRows = 9;

      // å›ºå®šç«‹æ–¹ä½“å¤§å°ï¼Œä¸éšç”»å¸ƒå˜åŒ–
      const cubeWidth = 60; // å›ºå®šå®½åº¦60px
      const cubeHeight = Math.floor(cubeWidth * 2.2 / 2); // 2.2:2 æ¯”ä¾‹ï¼Œé«˜åº¦ä¸ºå®½åº¦çš„1.1å€
      const depth = Math.floor(cubeWidth * 0.2); // æ·±åº¦æ¯”ä¾‹ 0.2
      const maxLayers = 4; // æœ€å¤š4å±‚

      // æ ¹æ®ç«‹æ–¹ä½“å¤§å°å’Œå±‚çº§åç§»è®¡ç®—æ€»å¸ƒå±€ç©ºé—´
      const baseGridWidth = gridCols * cubeWidth;
      const baseGridHeight = gridRows * cubeHeight;

      // è€ƒè™‘æœ€å¤§å±‚çº§çš„45åº¦åç§»
      const maxLayerOffset = (maxLayers - 1) * cubeWidth * 0.5 * Math.cos(Math.PI / 4);
      const totalWidth = baseGridWidth + maxLayerOffset;
      const totalHeight = baseGridHeight + maxLayerOffset;

      // è®¡ç®—å±…ä¸­ä½ç½®ï¼Œç¡®ä¿æ‰€æœ‰å±‚çº§éƒ½èƒ½æ˜¾ç¤º
      const startX = Math.floor((canvas.width - totalWidth) / 2);
      const startY = Math.floor((canvas.height - totalHeight) / 2);

      // éšæœºç”Ÿæˆç«‹æ–¹ä½“ä½ç½®å’Œå±‚çº§ - æ¯å±‚ç‹¬ç«‹éšæœº
      const cubes = [];

      // æ¯ä¸€å±‚ç‹¬ç«‹å†³å®šç«‹æ–¹ä½“çš„åˆ†å¸ƒ
      for (let layer = 0; layer < maxLayers; layer++) {
        for (let row = 0; row < gridRows; row++) {
          for (let col = 0; col < gridCols; col++) {
            // æ¯å±‚æ¯ä¸ªä½ç½®ç‹¬ç«‹éšæœºå†³å®šæ˜¯å¦æ”¾ç½®ç«‹æ–¹ä½“
            // åº•å±‚æ¦‚ç‡ç¨é«˜ï¼Œä¸Šå±‚æ¦‚ç‡é€’å‡ï¼Œå½¢æˆé‡‘å­—å¡”æ•ˆæœ
            const probability = 0.6 - (layer * 0.1); // å±‚0: 60%, å±‚1: 50%, å±‚2: 40%, å±‚3: 30%
            if (Math.random() < probability) {
              cubes.push({
                col,
                row,
                layer,
                symbol: SYMBOLS[Math.floor(Math.random() * SYMBOLS.length)]
              });
            }
          }
        }
      }

      // æŒ‰å±‚çº§æ’åºï¼Œå…ˆç»˜åˆ¶åº•å±‚
      cubes.sort((a, b) => a.layer - b.layer);

      // ç»˜åˆ¶æ‰€æœ‰ç«‹æ–¹ä½“
      for (const cube of cubes) {
        // æ–¹æ¡ˆCï¼šæ¯å±‚45åº¦è§’åç§»åŠä¸ªæ ¼å­
        const baseX = startX + cube.col * cubeWidth;
        const baseY = startY + cube.row * cubeHeight;

        // 45åº¦è§’åç§»ï¼šæ¯å±‚å‘å³ä¸‹åç§»åŠä¸ªæ ¼å­
        // 45åº¦è§’çš„åç§»é‡ = åŠä¸ªæ ¼å­ * cos(45Â°) å’Œ sin(45Â°)
        const halfGrid = cubeWidth * 0.5;
        const angle45 = Math.PI / 4; // 45åº¦è½¬å¼§åº¦

        const layerOffsetX = cube.layer * halfGrid * Math.cos(angle45);
        const layerOffsetY = cube.layer * halfGrid * Math.sin(angle45);

        const x = baseX + layerOffsetX;
        const y = baseY + layerOffsetY;

        // è®¡ç®—è¯¥ä½ç½®çš„æœ€å¤§å±‚çº§ï¼ˆç”¨äºç¡®å®šå½“å‰ç«‹æ–¹ä½“çš„ç›¸å¯¹æ·±åº¦ï¼‰
        const cubesAtPos = cubes.filter(c => c.col === cube.col && c.row === cube.row);
        const maxLayerAtPos = Math.max(...cubesAtPos.map(c => c.layer));
        const layerDepth = maxLayerAtPos - cube.layer; // 0ä¸ºé¡¶å±‚ï¼Œæ•°å€¼è¶Šå¤§è¶Šæ·±
        const isTopLayer = cube.layer === maxLayerAtPos && cubesAtPos.length > 1; // åªæœ‰åœ¨æœ‰å¤šå±‚æ—¶æ‰åŒºåˆ†é¡¶å±‚

        // å¦‚æœè¯¥ä½ç½®åªæœ‰ä¸€ä¸ªç«‹æ–¹ä½“ï¼Œæ ¹æ®å…¶ç»å¯¹å±‚çº§æ¥åˆ¤æ–­é¢œè‰²
        const shouldUseDarkColor = cubesAtPos.length === 1 ? cube.layer > 0 : !isTopLayer;

        // ç»˜åˆ¶ç«‹æ–¹ä½“ï¼ˆæ— é˜´å½±ï¼‰
        // åœ¨ä¸‰æ¶ˆæ¸¸æˆä¸­ï¼Œå±‚çº§æ•°å­—è¶Šå¤§è¡¨ç¤ºè¶Šåœ¨ä¸Šå±‚ï¼ˆè¶Šé è¿‘ç©å®¶ï¼‰
        drawCuboid(ctx, x, y, cubeWidth, cubeHeight, depth, {
          actualLayer: cube.layer // åªä¼ é€’å®é™…å±‚çº§
        });

        // ç»˜åˆ¶ç¬¦å· - æ‰©å±•è‡³ç«‹æ–¹ä½“è¾¹ç¼˜
        // ç«‹æ–¹ä½“å‰é¢æ˜¯æ­£æ–¹å½¢ï¼Œå›¾æ ‡å¤§å°æ¥è¿‘æ•´ä¸ªå‰é¢
        const fontSize = Math.floor(Math.min(cubeWidth, cubeHeight) * 0.9); // å‰é¢çš„90%ä½œä¸ºå­—ä½“å¤§å°
        ctx.font = `${fontSize}px system-ui`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // ç§»é™¤ç¬¦å·é˜´å½±

        // ä¸»ç¬¦å· - æ ¹æ®å±‚çº§è°ƒæ•´é¢œè‰²
        // å±‚çº§è¶Šé«˜ç¬¦å·è¶Šæ¸…æ™°
        if (cube.layer === maxLayers - 1) {
          // æœ€é«˜å±‚çº§ç¬¦å·ï¼šæ·±è‰²ï¼Œé«˜å¯¹æ¯”åº¦
          ctx.fillStyle = 'rgba(31, 41, 55, 1)';
        } else {
          // è¾ƒä½å±‚çº§ç¬¦å·ï¼šå±‚çº§è¶Šä½è¶Šé€æ˜
          const layerDiff = (maxLayers - 1) - cube.layer;
          const symbolOpacity = Math.max(0.4, 1 - (layerDiff * 0.2)); // æœ€ä½40%é€æ˜åº¦
          ctx.fillStyle = `rgba(31, 41, 55, ${symbolOpacity})`;
        }
        ctx.fillText(cube.symbol, x + cubeWidth / 2, y + cubeHeight / 2);
      }

      // ç»˜åˆ¶ç½‘æ ¼çº¿ï¼ˆè°ƒè¯•ç”¨ï¼‰- åŸºäºç«‹æ–¹ä½“å¤§å°
      ctx.strokeStyle = 'rgba(0,0,0,0.1)';
      ctx.lineWidth = 1;
      for (let i = 0; i <= gridCols; i++) {
        const x = startX + i * cubeWidth;
        ctx.beginPath();
        ctx.moveTo(x, startY);
        ctx.lineTo(x, startY + gridRows * cubeHeight);
        ctx.stroke();
      }
      for (let i = 0; i <= gridRows; i++) {
        const y = startY + i * cubeHeight;
        ctx.beginPath();
        ctx.moveTo(startX, y);
        ctx.lineTo(startX + gridCols * cubeWidth, y);
        ctx.stroke();
      }

      // æ˜¾ç¤ºå±‚çº§ç»Ÿè®¡ä¿¡æ¯
      const layerStats = {};
      cubes.forEach(cube => {
        layerStats[cube.layer] = (layerStats[cube.layer] || 0) + 1;
      });

      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.font = '14px system-ui';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      let infoY = 10;
      ctx.fillText(`æ€»ç«‹æ–¹ä½“: ${cubes.length}`, 10, infoY);
      infoY += 20;
      for (let layer = 0; layer < maxLayers; layer++) {
        const count = layerStats[layer] || 0;
        ctx.fillText(`å±‚${layer}: ${count}ä¸ª`, 10, infoY);
        infoY += 18;
      }
    }

    // åˆå§‹ç»˜åˆ¶
    drawScene();

    // åˆ·æ–°æŒ‰é’®äº‹ä»¶
    refreshBtn.addEventListener('click', drawScene);
  </script>
</body>

</html>