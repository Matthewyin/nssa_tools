<!doctype html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MLG 立方体样式测试</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .game-container {
      background: #F9FBE7;
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    }

    .game-canvas {
      background: #F9FBE7;
      border-radius: 8px;
      width: 100%;
      height: 700px;
      /* 进一步增加高度避免遮挡 */
    }
  </style>
</head>

<body class="min-h-screen bg-slate-100 p-4">
  <div class="max-w-4xl mx-auto">
    <h1 class="text-2xl font-bold mb-4">MLG 立方体样式测试</h1>
    <div class="mb-4">
      <button id="refresh-btn" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded">
        🔄 重新生成布局
      </button>
    </div>
    <div class="game-container">
      <canvas id="test-canvas" class="game-canvas"></canvas>
    </div>
    <div class="mt-4 text-sm text-gray-600">
      <p>测试新的立方体样式：</p>
      <ul class="list-disc list-inside mt-2">
        <li>方案C布局：每层7×9网格，45度角层级偏移</li>
        <li>浅黄色背景：#FFFFCC，温暖柔和</li>
        <li>层级颜色：顶层最亮 #E8F5E8，逐级变暗到底层 #A0B8A0</li>
        <li>边框颜色：对应的深绿色边框，层级越低越暗</li>
        <li>立体边框：主边框 + 高光边框 + 底部阴影线</li>
        <li>45度偏移：每层向右下偏移半个格子距离</li>
        <li>图标大小扩展至立方体边缘（90% 前面大小）</li>
        <li>每层独立随机分布：底层60%概率，上层递减10%</li>
        <li>有序层次：规律的偏移创造清晰的层次感</li>
      </ul>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('test-canvas');
    const ctx = canvas.getContext('2d');
    const refreshBtn = document.getElementById('refresh-btn');

    // 测试符号
    const SYMBOLS = ['🐱', '🐶', '🐭', '🐹', '🐰', '🦊', '🐻', '🐼', '🐨', '🐯', '🦁', '🐮'];

    // 颜色调整函数
    function adjustHexColor(hex, amount) {
      try {
        const m = /^#?([0-9a-fA-F]{6})$/.exec(String(hex || ''));
        if (!m) return hex;
        const v = m[1];
        const r = parseInt(v.slice(0, 2), 16);
        const g = parseInt(v.slice(2, 4), 16);
        const b = parseInt(v.slice(4, 6), 16);
        const clamp255 = (n) => Math.max(0, Math.min(255, Math.round(n)));
        const adj = (c) => clamp255(c + amount * 255);
        const toHex = (n) => n.toString(16).padStart(2, '0');
        return `#${toHex(adj(r))}${toHex(adj(g))}${toHex(adj(b))}`;
      } catch { return hex; }
    }

    // 绘制圆角矩形路径
    function createRoundedRectPath(ctx, x, y, width, height, radius) {
      const r = Math.max(2, Math.min(radius || 8, Math.min(width, height) / 4));
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + width - r, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + r);
      ctx.lineTo(x + width, y + height - r);
      ctx.quadraticCurveTo(x + width, y + height, x + width - r, y + height);
      ctx.lineTo(x + r, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
    }

    // 绘制立方体 - 左下倾斜方向，层级颜色区分
    function drawCuboid(ctx, frontX, frontY, frontW, frontH, depth, options) {
      const o = options || {};
      const actualLayer = o.actualLayer || 0;
      const maxLayers = 4;
      let frontColor, borderColor;

      // 每个层级都有不同的颜色，从顶层最亮到底层最暗
      const layerColors = [
        { front: '#A0B8A0', border: '#1A3010' }, // 层级0（底层）：最暗
        { front: '#B0C8B0', border: '#1F3515' }, // 层级1：较暗
        { front: '#C0D8C0', border: '#243A1A' }, // 层级2：稍亮
        { front: '#E8F5E8', border: '#2D5016' }  // 层级3（顶层）：最亮
      ];

      const colorIndex = Math.min(actualLayer, layerColors.length - 1);
      frontColor = layerColors[colorIndex].front;
      borderColor = layerColors[colorIndex].border;

      const radius = 6;
      const thickness = Math.floor(frontW * 0.1); // 厚度为宽度的0.1倍

      ctx.save();

      // 绘制右侧厚度面（体现厚度）
      if (thickness > 0) {
        const sideColor = adjustHexColor(frontColor, -0.2); // 侧面稍暗
        ctx.fillStyle = sideColor;
        ctx.beginPath();
        ctx.moveTo(frontX + frontW, frontY + radius);
        ctx.lineTo(frontX + frontW + thickness, frontY + radius - thickness);
        ctx.lineTo(frontX + frontW + thickness, frontY + frontH - radius - thickness);
        ctx.lineTo(frontX + frontW, frontY + frontH - radius);
        ctx.closePath();
        ctx.fill();

        // 侧面边框
        ctx.strokeStyle = adjustHexColor(borderColor, -0.1);
        ctx.lineWidth = 1;
        ctx.stroke();
      }

      // 绘制顶部厚度面（体现厚度）
      if (thickness > 0) {
        const topColor = adjustHexColor(frontColor, -0.15); // 顶面稍暗
        ctx.fillStyle = topColor;
        ctx.beginPath();
        ctx.moveTo(frontX + radius, frontY);
        ctx.lineTo(frontX + radius + thickness, frontY - thickness);
        ctx.lineTo(frontX + frontW - radius + thickness, frontY - thickness);
        ctx.lineTo(frontX + frontW - radius, frontY);
        ctx.closePath();
        ctx.fill();

        // 顶面边框
        ctx.strokeStyle = adjustHexColor(borderColor, -0.1);
        ctx.lineWidth = 1;
        ctx.stroke();
      }

      // 绘制主体矩形（正面）
      createRoundedRectPath(ctx, frontX, frontY, frontW, frontH, radius);
      ctx.fillStyle = frontColor;
      ctx.fill();

      // 绘制主边框
      ctx.strokeStyle = borderColor;
      ctx.lineWidth = 2.5;
      ctx.stroke();

      // 绘制内部高光边框（模拟立体效果）
      createRoundedRectPath(ctx, frontX + 2, frontY + 2, frontW - 4, frontH - 4, radius - 2);
      ctx.strokeStyle = adjustHexColor(frontColor, 0.15);
      ctx.lineWidth = 1;
      ctx.stroke();

      ctx.restore();
    }

    // 绘制场景
    function drawScene() {
      // 设置画布尺寸
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;

      // 清空画布 - 淡绿黄色背景
      ctx.fillStyle = '#F9FBE7';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // 7×9 网格布局测试（方案C）
      const gridCols = 7;
      const gridRows = 9;

      // 固定立方体大小，不随画布变化
      const cubeWidth = 60; // 固定宽度60px
      const cubeHeight = Math.floor(cubeWidth * 2.2 / 2); // 2.2:2 比例，高度为宽度的1.1倍
      const depth = Math.floor(cubeWidth * 0.2); // 深度比例 0.2
      const maxLayers = 4; // 最多4层

      // 根据立方体大小和层级偏移计算总布局空间
      const baseGridWidth = gridCols * cubeWidth;
      const baseGridHeight = gridRows * cubeHeight;

      // 考虑最大层级的45度偏移
      const maxLayerOffset = (maxLayers - 1) * cubeWidth * 0.5 * Math.cos(Math.PI / 4);
      const totalWidth = baseGridWidth + maxLayerOffset;
      const totalHeight = baseGridHeight + maxLayerOffset;

      // 计算居中位置，确保所有层级都能显示
      const startX = Math.floor((canvas.width - totalWidth) / 2);
      const startY = Math.floor((canvas.height - totalHeight) / 2);

      // 随机生成立方体位置和层级 - 每层独立随机
      const cubes = [];

      // 每一层独立决定立方体的分布
      for (let layer = 0; layer < maxLayers; layer++) {
        for (let row = 0; row < gridRows; row++) {
          for (let col = 0; col < gridCols; col++) {
            // 每层每个位置独立随机决定是否放置立方体
            // 底层概率稍高，上层概率递减，形成金字塔效果
            const probability = 0.6 - (layer * 0.1); // 层0: 60%, 层1: 50%, 层2: 40%, 层3: 30%
            if (Math.random() < probability) {
              cubes.push({
                col,
                row,
                layer,
                symbol: SYMBOLS[Math.floor(Math.random() * SYMBOLS.length)]
              });
            }
          }
        }
      }

      // 按层级排序，先绘制底层
      cubes.sort((a, b) => a.layer - b.layer);

      // 绘制所有立方体
      for (const cube of cubes) {
        // 方案C：每层45度角偏移半个格子
        const baseX = startX + cube.col * cubeWidth;
        const baseY = startY + cube.row * cubeHeight;

        // 45度角偏移：每层向右下偏移半个格子
        // 45度角的偏移量 = 半个格子 * cos(45°) 和 sin(45°)
        const halfGrid = cubeWidth * 0.5;
        const angle45 = Math.PI / 4; // 45度转弧度

        const layerOffsetX = cube.layer * halfGrid * Math.cos(angle45);
        const layerOffsetY = cube.layer * halfGrid * Math.sin(angle45);

        const x = baseX + layerOffsetX;
        const y = baseY + layerOffsetY;

        // 计算该位置的最大层级（用于确定当前立方体的相对深度）
        const cubesAtPos = cubes.filter(c => c.col === cube.col && c.row === cube.row);
        const maxLayerAtPos = Math.max(...cubesAtPos.map(c => c.layer));
        const layerDepth = maxLayerAtPos - cube.layer; // 0为顶层，数值越大越深
        const isTopLayer = cube.layer === maxLayerAtPos && cubesAtPos.length > 1; // 只有在有多层时才区分顶层

        // 如果该位置只有一个立方体，根据其绝对层级来判断颜色
        const shouldUseDarkColor = cubesAtPos.length === 1 ? cube.layer > 0 : !isTopLayer;

        // 绘制立方体（无阴影）
        // 在三消游戏中，层级数字越大表示越在上层（越靠近玩家）
        drawCuboid(ctx, x, y, cubeWidth, cubeHeight, depth, {
          actualLayer: cube.layer // 只传递实际层级
        });

        // 绘制符号 - 扩展至立方体边缘
        // 立方体前面是正方形，图标大小接近整个前面
        const fontSize = Math.floor(Math.min(cubeWidth, cubeHeight) * 0.9); // 前面的90%作为字体大小
        ctx.font = `${fontSize}px system-ui`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // 移除符号阴影

        // 主符号 - 根据层级调整颜色
        // 层级越高符号越清晰
        if (cube.layer === maxLayers - 1) {
          // 最高层级符号：深色，高对比度
          ctx.fillStyle = 'rgba(31, 41, 55, 1)';
        } else {
          // 较低层级符号：层级越低越透明
          const layerDiff = (maxLayers - 1) - cube.layer;
          const symbolOpacity = Math.max(0.4, 1 - (layerDiff * 0.2)); // 最低40%透明度
          ctx.fillStyle = `rgba(31, 41, 55, ${symbolOpacity})`;
        }
        ctx.fillText(cube.symbol, x + cubeWidth / 2, y + cubeHeight / 2);
      }

      // 绘制网格线（调试用）- 基于立方体大小
      ctx.strokeStyle = 'rgba(0,0,0,0.1)';
      ctx.lineWidth = 1;
      for (let i = 0; i <= gridCols; i++) {
        const x = startX + i * cubeWidth;
        ctx.beginPath();
        ctx.moveTo(x, startY);
        ctx.lineTo(x, startY + gridRows * cubeHeight);
        ctx.stroke();
      }
      for (let i = 0; i <= gridRows; i++) {
        const y = startY + i * cubeHeight;
        ctx.beginPath();
        ctx.moveTo(startX, y);
        ctx.lineTo(startX + gridCols * cubeWidth, y);
        ctx.stroke();
      }

      // 显示层级统计信息
      const layerStats = {};
      cubes.forEach(cube => {
        layerStats[cube.layer] = (layerStats[cube.layer] || 0) + 1;
      });

      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.font = '14px system-ui';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      let infoY = 10;
      ctx.fillText(`总立方体: ${cubes.length}`, 10, infoY);
      infoY += 20;
      for (let layer = 0; layer < maxLayers; layer++) {
        const count = layerStats[layer] || 0;
        ctx.fillText(`层${layer}: ${count}个`, 10, infoY);
        infoY += 18;
      }
    }

    // 初始绘制
    drawScene();

    // 刷新按钮事件
    refreshBtn.addEventListener('click', drawScene);
  </script>
</body>

</html>